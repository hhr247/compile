# 编译原理实验2

姓名：何鸿荣

学号：19335052

GitHub：

## 实验题目

用**LL(1)分析法**和**LR(0)分析法**两种方法设计实现算术表达式的语法分析器。

- 算数表达式至少支持加减乘除以及括号操作，即（+，-，*，/，（））。

## 实验原理

​	在我们的编译器模型中，语法分析器从词法分析器中获取一个由此法单元组成的串，并且验证这个串可以由源语言的文法生成。我们期望语法分析器能够以易于理解的方式报告语法错误。

​	处理文法的语法分析器大体上可以分成三种类型：通用的、自顶向下的、自底向上的。

​	编译器中最常用的文法分析器可以分成自顶向下和自底向上的。顾名思义，自顶向下的方法从语法分析树的顶部开始，想底部构造语法分析树，而自底向上的方法则从叶子节点开始，逐渐向根节点构造语法分析树。这两种分析方法中，语法分析器的输入总是从左到右的方式被扫描，每次扫描一个符号。

​	本次实验中需要实现的有LL分析法，属于自顶向下的文法分析器。LR文法属于自底向上的文法分析器。

## 实验过程

### 实验说明

本次实验中，我实现了两种语法分析器，分别采用**LL(1)分析法**与**SLR(1)分析法**。

其中实现的内容中，包括可以使用**分号分割的表达式**，**赋值表达式**，**二元运算符算术表达式**，以及部分的**一元运算符表达式**。

在这里我们规定使用到的终结符：

终结符表如下所示：

| 符号            | 对应终结符 | 符号         | 对应终结符 | 符号   | 对应终结符 |
| --------------- | ---------- | ------------ | ---------- | ------ | ---------- |
| ++ -- ! ~ + -   | $\omega_0$ | * / %        | $\omega_1$ | + -    | $\omega_2$ |
| <<  >>          | $\omega_3$ | <  <=  >  >= | $\omega_4$ | == !=  | $\omega_5$ |
| =  -= += ... ^= | $\omega_6$ | \|\|         | "\|\|"     | &&     | '&&'       |
| \|              | "\|"       | ^            | "^"        | &      | "&"        |
| (               | "("        | )            | ")"        | ;      | ";"        |
| 常数            | $c$        | 变量         | $v$        | 字符串 | $s$        |

在实现过程中，考虑到实现的C语言文法的运算符优先级，在实现LL1分析法的语法分析器中，会考虑运算符的优先级。

实现的运算符按照优先级表示如下所示：

| 运算符                             | 描述         |
| ---------------------------------- | ------------ |
| ++ -- ! ~ + -                      | 一元运算符   |
| * / %                              | 乘除法运算符 |
| + -                                | 加减法运算符 |
| << >>                              | 移位运算符   |
| <  <=  >  >=                       | 关系运算符   |
| ==  !=                             | 相等运算符   |
| &                                  | 位与运算符   |
| ^                                  | 位异或运算符 |
| \|                                 | 位或运算符   |
| &&                                 | 逻辑与运算符 |
| \|\|                               | 逻辑或运算符 |
| = -= += *= /= %= &= ^= \|= <<= >>= | 赋值运算符   |

### 实验设计

实现语法分析器主要有以下步骤：

1. 确定文法
2. 利用对应的文法构建分析表
3. 根据自顶向下或者自底向上方式，实现语法分析器。

接下来我们主要针对如何实现上述的步骤。

#### 文法构建

在C语言中，我们所能够实现的文法能够支持多个表达式，通过分号来分割，表达式中支持使用赋值表达式，算术表达式。由此我们开始构建C语言的文法规则。

我们将实现的表达式的文法设计如下：

**Statement** ->  **Expression** |**Statement** **expression**

**Expression** -> ";" | **Assignment_expression** ";"

**Assignment_expression** -> **unary_expression** $\omega_6$  **Assignment_expression** |**logic_or_expression**

**logic_or_expression** -> **logic_or_expression**  '||' **logic_and_expression** | **logic_and_expression**

**logic_and_expression** -> **logic_and_expression** "&&" **or_expression** | **or_expression**

**or_expression** -> **or_expression** '|' **xor_expression**  | **xor_expression**

**xor_expression** -> **xor_expression** '^' **and_expression** |  **and_expression**

**and_expression** -> **and_expression** '&' **equal_expression** |  **equal_expression**

**equal_expression** -> **equal_expression** $\omega_5$ **relation_expression** |**relation_expression**

**relation_expression** -> **relation_expression** $\omega_4$ **shift_expression** | **shift_expression**

**shift_expression** -> **shift_expression** $\omega_3$ **add_expression** | **add_expression**

**add_expression** -> **add_expression** $\omega_2$ **mul_expression** | **mul_expression**

**mul_expression** -> **mul_expression** $\omega_1$ **unary_expression** | **unary_expression**

**unary_expression**  -> $\omega_0$ **unary_expression**   | **T**

**T** -> $c$ | $v$ |$s$|'(' **Assignment_expression** ')'

其中，加粗字体表示为非终结符，花体字体与双引号内容表示为终结符。

#### LL分析法

由于初始的文法不属于LL文法，因此我们需要对文法进行一定的修改，使其符合LL文法，这样才能够使用LL(1)分析法实现语法分析器。

- 存在直接左递归，因此我们需要消除左递归
- 同一非终结符的多个候选式存在共同前缀，因此需要提取左公因子，直到非终结符中多个候选式不存在共同后缀为止。

将上述的文法转换成LL(1)文法，最终我们使用的LL(1)的文法如下所示：

我们使用缩写将上述文法中的非终结符表示出来，其中{}内的内容表示select集，select集后的数字表示产生式的编号:

**S** -> **E** $S_1$ {$\omega_0$,  $c$ , $v$ , $s$, '(', ";"} 0 | $\epsilon$ {#} **43**

$S_1$ -> **E** $S_1${$\omega_0$,  $c$ , $v$ , $s$, '(', ";")  **1**| $\epsilon$ {#}  **2**

**E** -> **AsE** ";" {$\omega_0$,  $c$ , $v$ , $s$, '(' , } **3** | ";"  {;}  **41**

**AsE** -> **UnE** $\text{AsE}_1$  {$\omega_0$,  $c$ , $v$ , $s$, '('  } **4**			

$\text{AsE}_1$ -> $\omega_6$  **AsE** {$\omega_6$} **5** |  $\omega$  **LoE** {$\omega$} **6** | $\epsilon$  {";",")",#} **42**

**LoE** ->**LaE ** $\text{LoE}_1$  {$\omega_0$,  $c$ , $v$ , $s$, '('  } **7** 	   

$\text{LoE}_1$ -> "||" **LaE** $\text{LoE}_1$ {"||"}  **8**| "$\epsilon$"  {$\omega_6$, ';' ,  ')', #}**9**

**LaE** -> **OrE** $\text{LaE}_1$  {$\omega_0$,  $c$ , $v$ , $s$, '('  }**10**			

$\text{LaE}_1$ -> "&&" **OrE** $\text{LaE}_1$ {"&&"}**11** |  $\epsilon$ {$\omega_6$,"||" ,';' ,  ')', #}**12**

**OrE** -> **XoE** $\text{OrE}_1$  {$\omega_0$,  $c$ , $v$ , $s$, '(' }**13**		  

$\text{OrE}_1$-> "|" **XoE**  $\text{OrE}_1$ {"|"}**14**	| $\epsilon$ {$\omega_6$,"||", "&&" ,';' ,  ')', #}**15**

**XoE** -> **AnE** $\text{XoE}_1$  {$\omega_0$,  $c$ , $v$ , $s$, '(' }**16**		   

$\text{XoE}_1$ -> "^" **AnE** $\text{XoE}_1$ {"^"}**17**	| $\epsilon$ {$\omega_6$,"||", "&&", "|" ,';' ,  ')', #}**18**

**AnE** -> **EqE** $\text{AnE}_1$  {$\omega_0$,  $c$ , $v$ , $s$, '(' }**19**		   

$\text{AnE}_1$ -> "&" **EqE** $\text{AnE}_1$ {"&"}**20**	| $\epsilon$ {$\omega_6$,"||", "&&", "|" ,"^" ,';' ,  ')', #}**21**

**EqE** -> **ReE** $\text{EqE}_1$  {$\omega_0$,  $c$ , $v$ , $s$, '('  } **22**  

 $\text{EqE}_1$ -> $\omega_5$ **ReE** $\text{EqE}_1$ {$\omega_5$}**23**	| $\epsilon$ {$\omega_6$,..."^", "&" ,';' ,  ')', #}**24**

**ReE** -> **ShE** $\text{ReE}_1$  {$\omega_0$,  $c$ , $v$ , $s$, '(' }**25**		   

 $\text{ReE}_1$ -> $\omega_4$ **ShE** $\text{ReE}_1$ {$\omega_4$}**26**	| $\epsilon$ {$\omega_6$,..."&", $\omega_5$ ,';' ,  ')', #}**27**

**ShE** -> **AdE** $\text{ShE}_1$  {$\omega_0$,  $c$ , $v$ , $s$, '(' }**28**

 $\text{ShE}_1$ -> $\omega_3$ **AdE** $\text{ShE}_1$ {$\omega_3$}**29**	| $\epsilon$ {$\omega_6$,...$\omega_5$ , $\omega_4$ ,';' ,  ')', #}**30**

**AdE** -> **MuE** $\text{AdE}_1$  {$\omega_0$,  $c$ , $v$ , $s$, '(' }**31**

$\text{AdE}_1$ -> $\omega_2$ **MuE** $\text{AdE}_1$ {$\omega_2$}**32**	| $\epsilon$ {$\omega_6$,...$\omega_4$ , $\omega_3$ ,';' ,  ')', #}**33**

**MuE** -> **UnE** $\text{MuE}_1$ {$\omega_0$,  $c$ , $v$ , $s$, '('  } **34**	     

$\text{MuE}_1$ -> $\omega_1$ **UnE**  $\text{MuE}_1$ {$\omega_1$} **35**	| $\epsilon$ {$\omega_6$,...$\omega_2$ , $\omega_1$ ,';' ,  ')', #}**36**

**UnE**  -> $\omega_0$ **UnE** {$\omega_0$}  **37** | **T** {$c$ , $v$ , $s$, '(' }**38**

**T** -> $c$ {$c$}**|** $v$ {$v$} |$s$ {$s$}  **39** |'(' **AsE** ')' {"("}**40** 

其中需要注意的是，原赋值表达式中，存在相同的select集{$\omega_0$,  $c$ , $v$ , $s$, '(' }，并且在赋值表达式中，可能会存在结束的可能，因此需要非常注意。 因此在构建LL1文法的时候，如6号产生式，需要重点关注赋值表达式。运算表达式相对来说较为简单。

对于赋值表达式的描述，我们允许6号文法中的$\omega$为UnE的follow集中二元运算符号的总和，而对于其余终结符，考虑到后续可能为空，我们选择使用$\epsilon$，代表需要进行归约。

将{$c$}，{$v$}，{$s$}看作同一种类型的内容，记为$obj$，按照select集中的内容，我们构建LL(1)分析表，构建结果如下所示：

| 分析表         | $obj$ | $\omega_0$ | $\omega_1$ | $\omega_2$ | $\omega_3$ | $\omega_4$ | $\omega_5$ | $\omega_6$ | $\omega$ | \|\| | &&   | \|   | ^    | &    | (    | )    | ;    | #    |
| -------------- | ----- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- | -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| S              | 0     | 0          |            |            |            |            |            |            |          |      |      |      |      |      | 0    |      | 0    | 43   |
| $S_1$          | 1     | 1          |            |            |            |            |            |            |          |      |      |      |      |      | 1    |      | 1    | 2    |
| E              | 3     | 3          |            |            |            |            |            |            |          |      |      |      |      |      | 3    |      | 41   |      |
| AsE            | 4     | 4          |            |            |            |            |            |            |          |      |      |      |      |      | 4    |      |      |      |
| $\text{AsE}_1$ |       |            |            |            |            |            |            | 5          | 6        |      |      |      |      |      |      | 42   | 42   | 42   |
| LoE            | 7     | 7          |            |            |            |            |            |            |          |      |      |      |      |      | 7    |      |      |      |
| $\text{LoE}_1$ |       |            |            |            |            |            |            |            |          | 8    |      |      |      |      |      | 9    | 9    | 9    |
| LaE            | 10    | 10         |            |            |            |            |            |            |          |      |      |      |      |      | 10   |      |      |      |
| $\text{LaE}_1$ |       |            |            |            |            |            |            |            |          | 12   | 11   |      |      |      |      | 12   | 12   | 12   |
| OrE            | 13    | 13         |            |            |            |            |            |            |          |      |      |      |      |      | 13   |      |      |      |
| $\text{OrE}_1$ |       |            |            |            |            |            |            |            |          | 15   | 15   | 14   |      |      |      | 15   | 15   | 15   |
| XoE            | 16    | 16         |            |            |            |            |            |            |          |      |      |      |      |      | 16   |      |      |      |
| $\text{XoE}_1$ |       |            |            |            |            |            |            |            |          | 18   | 18   | 18   | 17   |      |      | 18   | 18   | 18   |
| AnE            | 19    | 19         |            |            |            |            |            |            |          |      |      |      |      |      | 19   |      |      |      |
| $\text{AnE}_1$ |       |            |            |            |            |            |            |            |          | 21   | 21   | 21   | 21   | 20   |      | 21   | 21   | 21   |
| EqE            | 22    | 22         |            |            |            |            |            |            |          |      |      |      |      |      | 22   |      |      |      |
| $\text{EqE}_1$ |       |            |            |            |            |            | 23         |            |          | 24   | 24   | 24   | 24   | 24   |      | 24   | 24   | 24   |
| ReE            | 25    | 25         |            |            |            |            |            |            |          |      |      |      |      |      | 25   |      |      |      |
| $\text{ReE}_1$ |       |            |            |            |            | 26         | 27         |            |          | 27   | 27   | 27   | 27   | 27   |      | 27   | 27   | 27   |
| ShE            | 28    | 28         |            |            |            |            |            |            |          |      |      |      |      |      | 28   |      |      |      |
| $\text{ShE}_1$ |       |            |            |            | 29         | 30         | 30         |            |          | 30   | 30   | 30   | 30   | 30   |      | 30   | 30   | 30   |
| AdE            | 31    | 31         |            |            |            |            |            |            |          |      |      |      |      |      | 31   |      |      |      |
| $\text{AdE}_1$ |       |            |            | 32         | 33         | 33         | 33         |            |          | 33   | 33   | 33   | 33   | 33   |      | 33   | 33   | 33   |
| MuE            | 34    | 34         |            |            |            |            |            |            |          |      |      |      |      |      | 34   |      |      |      |
| $\text{MuE}_1$ |       |            | 35         | 36         | 36         | 36         | 36         |            |          | 36   | 36   | 36   | 36   | 36   |      | 36   | 36   | 36   |
| UnE            | 38    | 37         |            |            |            |            |            |            |          |      |      |      |      |      | 38   |      |      |      |
| T              | 39    |            |            |            |            |            |            |            |          |      |      |      |      |      | 40   |      |      |      |

然后我们根据LL1文法与LL1分析表，构建LL1分析器，该分析器能够正确的分析上述的文法。



#### SLR(1)分析法

为了方便，我们将所有二元操作符使用$\omega$替代，OpE代表所有需要二元操作符的表达式，于是我们的初始文法可以简化如下： 

我们扩展初始文法，使文法符号附有位置信息，构造句柄识别器：

**S'** -> **S** 1 **(0)**

**S** -> **S** 2 **E** 3  **(1)**| **E** 4 **(2)**

**E** -> ";" 5 **(3)** | **AsE** 6 ";" 7  **(4)**

**AsE** -> **UnE** 8  9 **AsE** 10 **(5)** | **OpE** 11 **(6)** 

**OpE** -> **OpE** 12 $\omega$ 13 **OpE** 14 **(7)** | **UnE** 15 **(8)** 

**UnE** -> $\omega_0$ 16 **UnE**  17 **(9)** | **T** 18 **(10)**

**T** -> $obj$ 19 **(11)** | "(" 20 **AsE** 21 ")" 22  **(12)**

此时，我们使用该文法进行构建LR(0)分析表的时候，在0状态遇到UnE的时候，会出现到达8状态与到达15状态的情况，因此需要对文法进行一定的修改，修改后带空边，因此需要使用SLR(1)的方法，这样子可以接受出现空边的情况，文法如下所示：

**S** -> **S** 1 **E** 2   **(0)** | **E** 3  **(1)**

**E** -> **AsE** 4 **";"** 5 **(2)** | ";" 6 **(3)**

**AsE** -> **UnE** 7  $AsE_1$ 8 **(4)**

$\text{AsE}_1$ -> $\omega_6$ 9 **AsE** 10 **(5)** |  $\omega$ 11  **OpE** 12  **(6)** | $\epsilon$  **(7)**

**OpE** ->**UnE** 13 $\text{OpE}_1$ 14 **(8)**

$\text{OpE}_1$ -> $\omega$ 15 **UnE** 16  $\text{OpE}_1$ 17 **(9)** | $\epsilon$  **(10)**

**UnE** -> $\omega_0$  18 **UnE** 19 **(11)** | **T** 20 **(12)**

T -> $obj$ 21 **(13)** | "(" 22 **AsE** 23 ")" 24 **(14)**

此时，在遇到不同的非终结符与终结符的时候，就能够跳转到不同的状态，并且保证了能够稳定的跳转到对应状态，由于引入了空边，因此选择使用SLR(1)的方法，这样子可以将空边转换为能够使用的内容。因此可得SLR(1)分析表，如下所示：

| 分析表 | $obj$ | $\omega$ | $\omega_0$ | $\omega_6$ | (     | )     | ;     | #     | S    | E    | AsE  | $AsE_1$ | OpE  | $OpE_1$ | UNE  | T    |
| ------ | ----- | -------- | ---------- | ---------- | ----- | ----- | ----- | ----- | ---- | ---- | ---- | ------- | ---- | ------- | ---- | ---- |
| 0      | 21    |          | 18         |            | 22    |       | 6     | OK    | 1    | 3    | 4    |         |      |         | 7    | 20   |
| 1      | 21    |          | 18         |            | 22    |       | 6     | OK    |      | 2    | 4    |         |      |         | 7    | 20   |
| 2      | R(0)  | R(0)     | R(0)       | R(0)       | R(0)  | R(0)  | R(0)  | R(0)  |      |      |      |         |      |         |      |      |
| 3      | R(1)  | R(1)     | R(1)       | R(1)       | R(1)  | R(1)  | R(1)  | R(1)  |      |      |      |         |      |         |      |      |
| 4      |       |          |            |            |       |       | 5     |       |      |      |      |         |      |         |      |      |
| 5      | R(2)  | R(2)     | R(2)       | R(2)       | R(2)  | R(2)  | R(2)  | R(2)  |      |      |      |         |      |         |      |      |
| 6      | R(3)  | R(3)     | R(3)       | R(3)       | R(3)  | R(3)  | R(3)  | R(3)  |      |      |      |         |      |         |      |      |
| 7      |       | 11       |            | 9          |       | R(7)  | R(7)  |       |      |      |      | 8       |      |         |      |      |
| 8      | R(4)  | R(4)     | R(4)       | R(4)       | R(4)  | R(4)  | R(4)  | R(4)  |      |      |      |         |      |         |      |      |
| 9      | 21    |          | 18         |            | 22    |       |       |       |      |      | 10   |         |      |         | 7    | 20   |
| 10     | R(5)  | R(5)     | R(5)       | R(5)       | R(5)  | R(5)  | R(5)  | R(5)  |      |      |      |         |      |         |      |      |
| 11     | 21    |          | 18         |            | 22    |       |       |       |      |      |      |         | 12   |         | 13   | 20   |
| 12     | R(6)  | R(6)     | R(6)       | R(6)       | R(6)  | R(6)  | R(6)  | R(6)  |      |      |      |         |      |         |      |      |
| 13     |       | 15       |            |            |       | R(10) | R(10) |       |      |      |      |         |      | 14      |      |      |
| 14     | R(8)  | R(8)     | R(8)       | R(8)       | R(8)  | R(8)  | R(8)  | R(8)  |      |      |      |         |      |         |      |      |
| 15     | 21    |          | 18         |            | 22    |       |       |       |      |      |      |         |      |         | 16   | 20   |
| 16     |       | 15       |            |            |       | R(10) | R(10) |       |      |      |      |         |      | 17      |      |      |
| 17     | R(9)  | R(9)     | R(9)       | R(9)       | R(9)  | R(9)  | R(9)  | R(9)  |      |      |      |         |      |         |      |      |
| 18     | 21    |          | 18         |            | 22    |       |       |       |      |      |      |         |      |         | 19   | 20   |
| 19     | R(11) | R(11)    | R(11)      | R(11)      | R(11) | R(11) | R(11) | R(11) |      |      |      |         |      |         |      |      |
| 20     | R(12) | R(12)    | R(12)      | R(12)      | R(12) | R(12) | R(12) | R(12) |      |      |      |         |      |         |      |      |
| 21     | R(13) | R(13)    | R(13)      | R(13)      | R(13) | R(13) | R(13) | R(13) |      |      |      |         |      |         |      |      |
| 22     | 21    |          | 18         |            | 22    |       |       |       |      |      | 23   |         |      |         | 7    | 20   |
| 23     |       |          |            |            |       | 24    |       |       |      |      |      |         |      |         |      |      |
| 24     | R(14) | R(14)    | R(14)      | R(14)      | R(14) | R(14) | R(14) | R(14) |      |      |      |         |      |         |      |      |

根据该文法，构建的流程图如下：

![graph](G:\学习\大三下\Compilers\hw2\graph.png)

然后我们根据SLR1文法与SLR1分析表，构建SLR1分析器，该分析器能够正确的分析上述的文法。

### 程序设计

在语法分析器中，由于语法分析器需要从词法分析器中获取token，因此在C语言中，使用class，将语法分析器进行封装，并且将上次任务完成的词法分析器进行封装，最后一起调用词法分析器与语法分析器，输入将要进行分析的文件名，首先对其进行词法分析，获取一个个token，然后使用语法分析器将token作为终结符输入，然后分别运行LL(1)分析器与SLR(1)分析器，代码如下：

```c++
#include"Lexical_analyzer.h"
#include"Syntactic.h"
int main() {
	char* fname;
	fname = (char*)(malloc(sizeof(char) * 256));
	cin >> fname;
	Lexical_analyzer Lex;
	Lex.Solution(fname);
	Syntactic Syn;
	Syn.LL1solution("tokens.txt");
	Syn.SLR1solution("tokens.txt");
}
```

其中，Lexical_analyzer.h中包含词法分析器的类，Syntactic.h包含语法分析器的类。

## 实验结果

程序中，会显示当前的栈中所存储的内容。

我们针对不同的功能进行不同的测试：

- 首先是尝试输入空文件，查看能否正确的识别。
  - 文件中没有任何的内容。
  - 此时我们词法分析器的输出为空。
  - 语法分析器正确输出应该为success。
  - 结果如下所示：
  - ![image-20220504164154731](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504164154731.png) 
  - 可以看到，两个语法分析器中都可以成功的识别空文件。

- 然后是分号的识别。

  - 连续的分号 如 “;;;“
  - 分号前面加入了")", 常数，变量等。
  - 分号后面接着 ”)“ , 常数，变量等。

  - 测试用输入如下：

    ```c
    ;;;
    a;
    (b);
    13;
    ```

  - 然后观察对应的实验结果：
  - 经过实验结果观察，我们可以看到在LL1分析法中，产生式的内容会以逆序压栈，然后会不断匹配终结符并出栈，直到遇到结束符。在分号的检测中，给出了Success的结果。
  - 我们可以看到在SLR1分析法中，会在栈中不断的对符合的产生式进行归约，最后会归约到OK的结果。在分号的检测中，给出了Success的结果。
  - LL1:     ![image-20220504165121316](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504165136817.png)
  - SLR1:  ![image-20220504165149735](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504165149735.png) 

- 然后是赋值语句的识别：

  - 赋值语句中，要求赋值号的左值为单个元素，也就是说左边不能是算术表达式，但是左边允许是括号。此时我们不考虑是否符合语义，赋值号左边的内容并不要求是左值变量。

  - 所以我们查看三种情况，一种是连续等于，一种是左边出现表达式，一种是左边使用括号。

  - 测试用输入如下：

  - ```c++
    a = b = c = d + e;
    a = (b + a + b) = c + d;
    a = b + a + b = c + d;
    ```

  - 按照规则，第三个表达式应该是需要被禁止的。

  - 首先是对第一个式子进行判断：

  - ![image-20220504170101737](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504170101737.png)

  - ![image-20220504170110324](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504170110324.png)

  - 可以看到，两种方法都成功了。

  - 然后是对第二个式子进行判断：

  - ![image-20220504171113592](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504171113592.png)

  - ![image-20220504171034293](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504171034293.png)

  - 同样的，对第二个式子，也是都能够成立；

  - 然后对第三个式子进行判断：

  - ![image-20220504171210780](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504171210780.png)

  - 在反馈中，可以看到，此时我们无法识别等号，这说明赋值号会出现问题。

- 然后是对算数表达式进行测试：

  - 主要针对不同的符号进行测试。

  - 我们按照优先级的逆序进行测试，测试用式子如下所示：

    ```
    a = ++a * b - --c >> 2 == 2 & 1 ^ e | 10 && b || c;
    ```

  - ![image-20220504171700683](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504171700683.png)

  - ![image-20220504171710838](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504171710838.png)

  - 此时可以看到，在两种分析法中都能成功识别。

  - 然后是错误的验证，我们查看连续输入两个运算符，或者连续输入两个变量或常量，或者尝试缺失一个变量，验证是否会提示报错。

    ```
    / a;
    a b;
    + +;
    ```

  - 实验输出分别如下：

  - ![image-20220504172231827](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504172231827.png)

  - ![image-20220504172316817](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504172316817.png)

  - ![image-20220504172256260](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504172256260.png)

  - 可以看到，期望输入都不匹配。

- 然后是针对括号的测试，测试分成三种：

  - 一种是左右括号对应，一种是左右括号不对应，还有一种是括号内无内容；

    ```
    (a);
    ((((b)));
    ();
    ```

  - 对于第一种情况，可以看到都能够成功识别

  - ![image-20220504172502980](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504172502980.png) ![image-20220504172508407](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504172508407.png) 

  - 对于第二种情况，可以看到，期望得到")"但是没有对应的字符。

  - ![image-20220504172554524](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504172554524.png)

    ![image-20220504172604703](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504172604703.png)

  - 对于第三种情况，可以看到期望其中出现表达式。

  - ![image-20220504172637627](C:\Users\hhr\AppData\Roaming\Typora\typora-user-images\image-20220504172637627.png)

经过测试，可以实现大部分表达式中的内容，并且实现分号的使用。

在这里，重点测试赋值号的规则，使得赋值表达式能够正常的运行。

## 实验心得

在实现的时候，遇到了不少的问题，因为多实现了关于赋值表达式的规则，而赋值表达式按照C语言的规则，左值是不允许作为表达式出现的，所以需要对左边的元素个数进行限制，因此，可能会出现单个元素单走的情况，这个时候，我们难以判断是使用算数表达式计算，还是用赋值表达式计算，因此在这里需要考虑后续接的内容是什么，当我们只有单个的时候，我们需要引入空边，允许我们后续接的内容是UnE的follow集，这个时候我们还要分成几种情况，若是后续接入的内容为等号，我们就视为赋值表达式，若是后续接入的内容为运算符，我们就视为二元表达式的计算，若是后续接入的内容为分号或者括号，这种情况就视为空边。通过一段时间的研究，我才能够实现相关的表达式实现。

在本次实验中，仍然发现有不足的地方，比如说可以减少文法的复杂度，将所有的二元运算符文法视作同一种类型，尽管会失去优先级的比较，但是这样子能够减少文法表示的量。因此在SLR分析法中尝试了一下，发现效果还不错，对于基本的表达式还是能够顺利的识别。

除此之外，在进行设计的过程中，还学会了LL1文法的变换过程，能够亲自将其变换成LL1文法。

